Вопрос 6

Представим, что мы пишем карточную игру.

a) В колоде 52 уникальных карты (13 рангов карт по 4 масти). 
Создайте перечисления для рангов карт (2, 3, 4, 5, 6, 7, 8, 9, 10, 
валет (Jack), дама (Queen), король (King), туз (Ace)) и 
мастей (трефы (clubs), бубны (diamonds), червы (hearts), пики (spades)). 
Эти перечислители не будут использоваться для индексации массивов.

b) Каждая карта будет представлена структурой с именем Card, которая содержит ранг (rank) и масть (suit). 
Создайте структуру.

c) Создайте функцию printCard(), которая принимает ссылку на const Card в качестве параметра и 
печатает ранг и масть карты в виде двухбуквенного кода 
(например, пиковый валет будет печататься как JS (от jack spades)).

d) В колоде 52 карты. 
Создайте массив (используя std::array) для представления колоды карт и 
инициализируйте его по одной карте каждого типа. 
Сделайте это в функции с именем createDeck и вызовите createDeck из main. 
createDeck должен вернуть колоду в main.

Подсказка: используйте static_cast, если вам нужно преобразовать целочисленный тип int в перечислимый тип.

e) Напишите функцию с именем printDeck(), 
которая принимает колоду в качестве параметра константной ссылки и печатает карты в колоде. 
Используйте цикл for на основе диапазона. 
Когда вы вызовете printDeck с колодой, которую вы создали в предыдущей задаче, вывод должен быть таким:

2C 3C 4C 5C 6C 7C 8C 9C TC JC QC KC AC 2D 3D 4D 5D 6D 7D 8D 9D TD JD QD KD AD 
2H 3H 4H 5H 6H 7H 8H 9H TH JH QH KH AH 2S 3S 4S 5S 6S 7S 8S 9S TS JS QS KS AS

Если вы использовали другие символы, это нормально.

f) Напишите функцию с именем shuffleDeck для перетасовки колоды карт с помощью std::shuffle. 
Обновите свою функцию main, чтобы перетасовать колоду и распечатать ее уже перетасованной.

Напоминание: инициализируйте генератор случайных чисел только один раз.

g) Напишите функцию с именем getCardValue(), 
которая возвращает значение карты (например, 2 стоит 2, десятка, валет, дама или король стоят 10. 
Предположим, что туз стоит 11).


Вопрос 7

а) Хорошо, время бросить вызов! Напишем упрощенную версию блэкджека. 
Если вы еще не знакомы с блэкджеком, в Википедии есть статья с кратким описанием.

Вот правила нашей версии блэкджека:

 -  для начала дилер получает одну карту 
 (в реальной жизни дилер получает две, но одна закрыта, поэтому на данном этапе это не имеет значения);
 -  для начала игрок получает две карты;
 -  игрок ходит первым.
 -  игрок может многократно сказать «еще» (hit) или сказать «достаточно» (stand);
 -  если игрок говорит «достаточно», его ход заканчивается, 
 и его счет рассчитывается на основе карт, которые ему были розданы;
 -  если игрок говорит «еще», он получает еще одну карту, 
 и значение этой карты добавляется к его общему счету;
 -  туз обычно засчитывается как 1 или 11 (в зависимости от того, что лучше для общего счета); 
 для простоты мы будем считать здесь 11;
 -  если у игрока больше 21 очка, он сразу же проигрывает;
 -  дилер ходит после игрока;
 -  дилер несколько раз тянет карты, пока не наберет 17 или более очков, после чего он останавливается;
 -  если у дилера больше 21 очков, он проигрывает, и игрок немедленно выигрывает;
 -  в противном случае, если у игрока больше очков, чем у дилера, игрок выигрывает. 
 В противном случае игрок проигрывает (для простоты мы будем рассматривать ничью как выигрыш дилера);
 -  в нашей упрощенной версии блэкджека мы не будем отслеживать, какие именно карты были сданы игроку и дилеру. 
 Мы будем отслеживать только сумму значений карт, которые были розданы игроку и дилеру. Это упрощает работу.

Начните с кода, который вы написали в вопросе 6. Создайте функцию с именем playBlackjack(). 
Эта функция должна:

 -  принимать в качестве параметра перетасованную колоду карт;
 -  реализовывать партию блэкджека, как описано выше;
 -  возвращать true, если выиграл игрок, и false, если он проиграл.

Также напишите функцию main() для одиночной игры в блэкджек.

b) Дополнительное задание: 
время критического мышления: 
опишите, как вы можете изменить приведенную выше программу, 
чтобы справиться со случаем, когда тузы могут быть равны 1 или 11.

Важно отметить, что мы отслеживаем только сумму карт, а не то, какие именно карты есть у пользователя.

c) В реальном блэкджеке, если у игрока и дилера одинаковый счет (и у игрока нет перебора), 
результатом считается ничья, и ни один из них не выигрывает. 
Опишите, как бы вы изменили приведенную выше программу, чтобы учесть это.